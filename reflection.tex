% !TEX root = ./main.tex
\sctn{Reflection}
\ssctn{Problems Encountered}
Problems in software development projects are inevitable. Carefully planning the time required for each task provides a cushion in case of unforeseen circumstances. This cushion allowed me to work around my inexperience with porting software. Additionally, my inexperience required a change to the requirements, however, due to careful planning I had enough time to comfortably complete the required tasks.\\\\
%
The research stage provided me with the opportunity to alleviate some of my inexperience. By researching around KoMoDo my aim was to make an educated decision regarding how best to improve it. However, it is clear to me now that my focus should have been on understanding the intricacies of porting software. The lack of understanding translated poorly to the implementation stage, where, the major problems with porting the legacy software were discovered. I do believe however, that in the future when encountering legacy software I can better identify the potential problems that development will face.\\\\
%
Looking into, and documenting, KoMoDo was no easy task. Countless hours were spent deciphering the cryptic comments or lack there of. I believe that without \itl{GDB}, the GNU Debugger, I would not have understood the convoluted mess that is KoMoDo. From the layout and the style of code it became increasingly clear that it was implemented by a single person, over some time. Variables and functions were occasionally in incorrect header files and KoMoDo was rife with comments like; `What does this even do? Magic.'. I do believe however, that thanks to the vague or non-existent comments and \itl{GDB}, I have become better at reading and understanding code. Additionally, I have honed in my skills as a `chameleon' programmer, writing code which mimics the standards of the source. Alternatively, to help future developers better understand KoMoDo, I made sure to comment on the intricate parts of the source, with which I had developed experience.\\\\
%
\itl{GTK1's} documentation has been purged from the internet, this made implementation using \itl{GTK1} very difficult. There exists a small number websites with a subset of the original documentation, these combined with what was already written in KoMoDo allowed me implement new features. Additionally, I used the \itl{GTK2} documentation to supplement what certain functions should do. The process of understanding and using the \itl{GTK1} API was time consuming and laborious, but doing so provided me with the relevant knowledge to carry out the necessary work.\\\\
%
Newer iterations of \itl{GTK} use the UI generation software, \itl{Glade} to design and implement the UI. KoMoDo was built before \itl{Glade's} inception. Consequently, the UI in KoMoDo is hard coded, and uses the \func{.komodo} config file to determine what is drawn to the main view. When attempting to move to \itl{GTK2} it became evident that the UI would need to be developed using \itl{Glade}. On top of \itl{Glade} consistently crashing, the new UI meant that a lot of the existing features in KoMoDo would need to be permanently disabled. They would need to be disabled due to the static structure of the \itl{Glade} files not allowing dynamic UI changes. The loss of features further pushed me into using \itl{GTK1}.
%
%
%
%
\ssctn{System Evaluation}
Due to the problems encountered a small number of requirements could not be met in their original context. For instance, providing compatibility across multiple platforms programmatically. However, additional effort was made to provide a solution, a virtual machine was created for users who prefer to use KoMoDo++ offline.\\\\
%
Some requirements, such as theming the UI could not be met because of library restrictions. However, by using clever design and reducing cognitive load, the new UI is much easier to work with, reducing the need for customized themes.\\\\
%
The remainder of the requirements, I believe were met in full. Users are given a clean UI which focuses their attention on the source code. Where possible, images were used to represent functionality, this contributes to the reduction of cognitive stress. The UI was designed to be more in line with interfaces developers are used to, thereby making it intuitive to use. Additionally, by using visual cues to notify the user of changes, users are made to feel in control, further reducing cognitive stress.\\\\
%
In addition to the requirements, KoMoDo++ should now be more stable. Talking to my peers for a list of improvements also yielded a list of bugs. I systematically went through the list and fixed them. Users should now experience less downtime when using KoMoDo.\\\\
%
I believe that although not all of the original requirements were met, the revised requirements were met in full. KoMoDo++ is a product developed to the best of my abilities, using the breadth of knowledge gathered from my experiences. I believe that thanks to my experiance I was able to move KoMoDo forward.
%
%
%
\ssctn{Personal Reflection}
I was drawn to this project because of the insight and understanding that the first year module, G51CSA provided me. As a developer the module allowed me to take into consideration the machine level results of my programming decisions. I felt as though KoMoDo needed to be made more accessible to students so that they could also develop this intuition. As one of the key first year modules, in the Computer Science course, at the University of Nottingham, every student is exposed to KoMoDo.\\\\
%
I felt as though my experience until now, as a Computer Science student had best prepared me to take on this challenge. I was both right and wrong, I am able to manage my time efficiently and to quickly implement software requirements. However, my lack of experience with legacy systems and porting software, made this project difficult. I was unable to see the pitfalls of moving from one API to another. Thankfully, due to my time management I was able to work around this oversight and get back on track. I think that I have now gained the relevant experience for future projects.\\\\
%
%how year out helped, experience with modules, c, build tools etc.
I felt as though my year in industry at Intel helped me prepare for this project. Working at Intel exposed me to a variety of technologies and scenarios. Most notably, I worked on a large open source project called MRAA which is on all of Intel's Internet of Things devices. Working on the project exposed me to build tools such as \itl{AutoMake}. Having prior knowledge of using \itl{AutoMake} gave me an advantage when it came to fixing some of the build issues with KoMoDo. Furthermore, working on the open source project allowed me to gain experience looking through someone else's code, understanding what it does and writing useful documentation. All of these skills translated very well when it came to understanding how KoMoDo operated.\\\\
%
At University, I have had the opportunity to build interactive systems, use C and objectively evaluate my choices. All of these opportunities have given me greater insight when working with KoMoDo. Additionally, I was able to make strategic decisions about how best to advance both KoMoDo's UI and, its features so that they adhered to the requirements..\\\\
%
For this particular project I believe that my time management and planning skills really showed. I managed to work around and fix issues that I encountered quickly, producing a high quality piece of work. Using the Agile methodology I setup sprints each week, these sprints were based on the tasks on my Kanban. The flexibility of using sprints allowed me dynamically change my pace so that I could work on other modules when needed. The Kanban allowed me to easily track my progress through the requirements.\\\\
%
%Early and frequent drafts
Although I have already submitted one dissertation, I felt as though my writing skills were still weak. This was further verified when I submitted my initial proposal to Professor David Brailsford. My personal aim during this second dissertation was to provide early and often drafts of the write-up. I was lucky that Professor Brailsford was able to consistently provide me with feedback about my work. I believe\footnote{David may disagree} that thanks to his efforts and lectures \footnote{Many grammar lectures} I have improved my technical writing ability.\\\\
%
In summary, I believe that I have thoroughly applied myself doing this dissertation. I have gained valuable expertise in working with legacy systems and understanding their complexity. Furthermore, I believe that I was able to further put into practice the skills I have gained both in industry and via University.
%
%
%
\sssctn{External Reflection}
Some of the original requirements for KoMoDo were not fully met. Lack of experience crippled the implementation stage. However, through my failures, Universities that teach their students using KoMoDo have a better idea of its limitations. Furthermore, thanks to my research and progress a foundation has been established on which KoMoDo can be recreated. Any developer that wishes to develop a modern KoMoDo can refer to my findings and avoid the mistakes I made. I believe that although I did not meet all of the specification, my work is to a high standard that can be carried on in the future.
%Although the original requirements were not met, the Universities which use KoMoDo now have a better idea about its limitations.
%
%
%
\ssctn{Future Improvements}
I would strongly recommend against any future improvements to KoMoDo as it now exists. Instead KoMoDo should be rebuilt from the ground up. KoMoDo shows signs of the age in which it was created. By using modern frameworks and techniques a `new' KoMoDo would last much longer. Careful planning can make KoMoDo easier to upgrade and maintain in the future.\\\\
%
Any improvements to KoMoDo would be likely to create more problems than solutions. However, there are many ways that KoMoDo can be improved: things such as how code is loaded into the memory or how \func{KMD} code is compiled, these can be further refined and streamlined. In the case of code compilation it could be changed to follow a plugin interface, so that users can change the compilation method \itl{ad hoc}. Additionally, rebuilding KoMoDo can allow it to be operating system agnostic, a definite plus for students who may not want to use Linux. KoMoDo was purpose-made to be a generic debugger, able to work with FPGA's, ARM boards and emulators. Although it is no longer used in a production environment, these features should be kept in future iterations.
