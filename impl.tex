% !TEX root = ./main.tex
\sctn{Implementation}
  \ssctn{Complications}
  Unfortunatly, KoMoDo turned out to be far more complex than originally thought\footnote{More of a pandoras box really}. Some of the issues encountered are discussed further within this section. The conclusion outlines the rest of the plan for KoMoDo.
    \sssctn{User-interface}
    When KoMoDo was concieved Glade, the visual UI creator did not exist. Consequently, all of KoMoDos UI is hardcoded, therefore each element is individually packed into containers, shown to the user and even manipulated. The tight coupling between the UI and KoMoDo itself poses porting challenges as a large percentage of features are deprecated in later iterations.\\\\
    %
    Furthermore, later iterations of GTK allow the developer to theme their application using CSS styling, with each UI element being part of a CSS selector. With GTK1 this isn't quite possible, it requires the use of themeing software such as QTCurve which, changes the UI of all GTK built applications.\\\\
    %
    Finally, one of the features discussed was syntax highlighting for the memory display, with GTK2 onwards the treeview requires that the data structure contain a class which knows how to draw the column data onto the view. GTK2 would have made implementing this feature far simpler, allowing each instruction to be highlighted accordingly. This is not possible in GTK1, the CLIST is a rigid widget which draws only text/pixmaps onto the screen. Furthermore, colouring is limited to rows or columns as opposed to individual characters. A possible way to over come this issue is to generate pixmaps which represent the machine instructions, drawing them onto the list instead.
    %GTK2 allows themeing via CSS, GTK1 does not, possibility to theme using qtcurve
    %Syntax highlighting requires ability to render own text
    \sssctn{Porting to GTK3}
    The original idea was to port KoMoDo to a recent stable version of GTK. Porting to GTK3 would have prolonged KoMoDos shelf life. With proper maintenance KoMoDo on GTK3 could have been kept relevant for years to come. Unfortunatly, GTK3 deprecates features found in GTK2 while completely removing features that were originally deprecated in GTK2. Moreover, GTK3 changes how widgets and various logic is used.\\\\
    %
    At this point it was evident that GTK3 is a far stretch, with so many changes to the program flow it would be better to reimplement KoMoDo from the ground up, something which took the original creators far longer than is permitted for the scope of this project.
    %instant issues due to major API overhaul
    %clists dropped in favour of treeviews
    \sssctn{Porting to GTK2}
    GTK2 was the next target library after GTK3 proved to be far more jarring. GTK2 allows for deprecated features to be enabled, this would allow for iterative changes to the UI without breaking everything.\\\\
    %
    To begin with Glade was used to implement the UI change proposed in the design chapter. Glade for GTK2 came with its own problems. Glade would often crash (tested on multiple devices) the crash would cause inconsistencies within the XML interface file, forcing a redo. This was a lesson quickly learnt, due to the nature of this work version control was already in use. Consequently, regular backups after even minor changes were made.\\\\
    %
    Using the Glade interface file is straight forward and only requires a few GTK function calls. Problems arose when connecting the glade UI with the old logic, Glade didn't allow the use of deprecated features. Therefore, it was necessary to port some of the code over to use the new treeview implementation. In a broad sense this was successful, but in actual fact it introduced buggy logic between the old GTK1 code and the new GTK2 code. Additionally, the documentation and coding style were far from desireable, it was evident from the sparse comments asking 'what does this do' that the majority of KoMoDo was implemented by a single person. Furthermore, many of KoMoDos features needed to be disabled so that the new UI could be integrated, something that would be detrimental to KoMoDo.
    % There exists a flag which allows for deprecated features to be enabled
    % The new user interface is written in glade
    % clsists exist but are part of the deprecated features
    % new uses treeview, using treeview causes alot of features to be dropped due to logic differences
    % alot of unkowns still exist documentation is lax,
    \sssctn{Conclusion}
    After battling with GTK2, GTK3 and Glade it was evident that KoMoDo should be rebuilt from the ground up, something which could become either an opersource or group project. Further deliberation and meetings with Professor David Brailsford fortified this conclusion. Most of the jimulator and parts of chump could stay relatively unchanged, but KoMoDo would need to be completely rewritten. This would bring about greater oppertunity to do things correctly and removed tight coupling between the UI and logic.\\\\
    %
    Consequently, to atleast improve KoMoDos current UI, work will be carried on using GTK1, building features onto KoMoDo 'as is' while refining the UI. Reducing some of the buttons in the action bar should bring KoMoDo more inline with the design of other IDEs, making it more intuitive to use. Working the breakpoints into the memory display will allow for more intuitive use, all this can be achieved while still maintaining the complex memory window. Moreover, some sort of memory visualization which would display occupied sectors could be useful to programmers. Finally, converting some of the buttons into pictures will help to convey their use.
    %Porting is not feasible, would be better to re-implement KoMoDo from the ground up
    %including logic.
    %Working with the current system is better, can provide consistancy within the code
    %UI can still be improved, reducing clutter

  \ssctn{Language and platform decisions}
  Both the language and platform that KoMoDo is being iterated on are pre-determined due to the existing software. KoMoDo as discussed in the frameworks chapter uses GTK+ 1.2 and Glib 1.2 . Due to the complications with porting no further changes will be made to the API version for GTK and Glib.\\\\
  %
  As for language KoMoDo was written in pure C and so any changes to the logic will also be made using C.\\\\
  %
  Furthermore, the primary platform that KoMoDo needs to run on is *nix. It will be developed primarily on a *nix machine and then if possible, on other platforms. The choice of framework is the deterministic factor when attempting to run on multiple platforms. In KoMoDos case it is heavily dependent on GTK and Glib. Consequently, KoMoDo would require a full rewrite to make it platform independent.
  %predetermined due to the nature of the project
  %using GTK+ 1.2 and Glib 1.2
  \ssctn{Tools and technologies}
  \sssctn{Building}
  KoMoDo is built using GCC but uses Autoconf and Make to configure the correct library paths and includes. The external libraries are dynamically linked with KoMoDo, this means that the user must first install the KoMoDo dependencies.

  \sssctn{Code}
  Code is written in a text editor, in particular Vim. Vim is a barebones editor with no minimal functionality. It is fast, reliable and comes with a whole host of useful features.\\\\
  KoMoDo is being developed on an Intel NUC running Arch Linux. As the main driver the NUC is fast and runs a barebones Linux build which is perfect for development.

  \sssctn{Backups}
  GitHub hosts Git which is a distributed version control system and the primary form of backup. Along with GitHub backups are regularly made to google drive and Dropbox, with the GitHub backup always being the most up-to-date. Git branches are used to test and work on features which are in progress, this keeps the Master branch functional. Finally, minor changes are often committed so that a full log of the progress is maintained.

  \sssctn{Progress management}
  A Kanban is used to track features through the inception/implementation/testing/complete phases. Regular sprints are used typically taking place from Wednesday through to Saturday. The sprints are for both the documentation and code. The overall progress is monitored using a Gantt chart.
  %Vim for text editing
  %built on an Intel Nuc
  %
  \ssctn{Project management}
  Project management is an important part of the software development pipeline. But software projects are subject to failure due to several factors \cite{software_failure}:
  \itm{
    \item Unrealistic project goals
    \item Badly defined system requirements
    \item Poor project management
    \item Sloppy development practices
  }

  Software developers now are far more conscious of the development demands and can better determine outlandish goals. They acquire these via university, accelerator courses or while on the job. Some, may not understand the gravity of their decisions until such time as project implementation begins. This is all part of the experience of becoming a developer.\\\\
  %
  Early development of the requirements and research somewhat aided in the decisions made with regards to this project. However, there was no prior experience porting code to more relevant APIs. The realisation that porting was out of the question put the project at risk. Alternatively, it is a valuable lesson in dealing with legacy systems.\\\\
  %
  Due to the diligent time planning the errors in judgement where inconsequential to the overall software development. Planning for issues is all part of using a Gant chart. Furthermore, using the agile approach meant that both the software and write-up were quickly progressed to reflect the change in requirements. The use of a Kanban aided in micro progress updates as the project was being developed.\\\\
  %
  Finally, regular meetings with everyone involved in the project meant they were kept up-to-date. This provided a great deal of flexibility and trust to be established by both parties.

  \ssctn{Implementation of software}
  Software development was carried out with the best coding practices in mind. Additionally, it was important to develop code which was inline with the current style, this would enable future developers to more readily become accustomed to the already in-place coding practices.
  \sssctn{Prototype}
  The prototype can be thought of as the current version of KoMoDo. Modifications to the UI and functionality are derived from the intended design changes. Additionally, new features which were discussed as part of the requirements are part of the final working product. The actual duration of the prototyping phase extends from the initial research into KoMoDos inner workings all the way up to the start of the implementation. \\\\
  %
  The breadth of the prototyping phase is due to the nature of the project, it is crucial to understand how the components already existent in KoMoDo interact and their implications. Furthermore, it was important to fully develop an idea of what KoMoDo already had in place, there are many features in KoMoDo that due to the convoluted UI are obfuscated.
  \sssctn{Final product}
