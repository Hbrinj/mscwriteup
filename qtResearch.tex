% !TEX root = ./main.tex
\graphicspath{ {images/research/} }
\sctn{Frameworks}
%
KoMoDo++ is designed with the future in mind. To achieve this there are several important requirements that a framework needs. How are the user interfaces and experiences built? Is it portable to other architectures? The frameworks ease to use and what are the manipulations required to KoMoDo. To determine the best framework to use this section will explore three different approaches, weighing their pros and cons as well as how well they meet the requirements. Any additional features which will be useful to KoMoDo++ will also be highlighted.
%
\ssctn{GTK}
\fig{\centering\img{0.5}{gimp}}{GIMP image editor built using GTK\cite{wikipedia_gimp}}{gtkgimp}
KoMoDos front-end is written using GTK, a Linux based UI framework. GTK was initially developed due to the closed source nature of QT. GTK boasts about its cross-compatibility and feature rich environment\cite{gtk}. It provides bindings for a host of languages but most importantly for C. The  `look and feel' of GTK applications can be styled using themes to provides a consistent visual appearance across platforms, although, this can vary depending on the host system. Compatibility outside of Linux requires additional applications to be installed so that the native GTK applications can be compiled. In this section we explore some of the features provided by GTK.
  \sssctn{Glade}
  Glade is a cross-platform UI generator, built to support GTK applications \cite{glade}. One of the more prominent applications that works both on Windows and *nix is GIMP, an image manipulation program. Glade provides a plethora of useful UI elements and is easy to use. The original KoMoDo UI was generated using Glade, so porting the existing code to the newer UI would be straight forward.\\\\
  %
  Glade is similar to many other UI generators implemented by other frameworks/libraries. Moreover it has been designed to be easy to start developing with. Glade generates XML files which represent the UI, these are internally used by GTK to generate the view.
  % UI generator
  \sssctn{MinGW and MSys}
  MinGW is a minimalist GNU development environment for Windows \cite{mingw}, it provides the header files required by Linux based applications and GCC so that applications can be compiled on Windows. MinGWs header files are actually bindings to their Windows counterparts.\\\\
  %
  MinGW also provides abstractions for threading on Windows via the use of MSys\cite{msys}. MSys is a light-weight implementation of Cygwin, a popular Linux shell interpreter system. Via the use of MSys, Linux features such as \itl{fork()} are exposed to developers for use, limiting changes to the code base for compatibility with Windows.
  % cross platform compiler providing linux like headers to compile for Windows
  \sssctn{Callbacks}
  GTK uses callbacks as a mechanism to execute the program logic. It exposes the callbacks to the GTK UI system using a series of preprocessor directives. When the preprocessor is executed the directives wrap the callback with the required functionality. The callback is then executed when the user interacts with UI elements.\\\\
  %
  GTK provides a host of functionality which relies on callbacks. In particular KoMoDo makes heavy use of the \itl{`g\_timeout\_add()'} function, in particular it uses this to update the register and program data from the Jimulator. Using callbacks in this way has one major issue, the callback is tightly coupled with the caller, reducing both extensibility and reusability.

  \sssctn{Internationalization/localisation}
  GTK attempts to make localisation easier by providing functionality that the programmer can use to translate UI text \cite{gtk_localisation}. GTK at compile time will generate a file containing the translatable text, this can be given to translators for translation. Once translated the inclusion of the file at install time allows GTK to pick the right string for the locale. Its built-in preprocessor directive provides wrapper code for the \itl{`gettext()'} function. This function at runtime checks the users locale and will, if available, place the correct translation into the application.

  % Simple callbacks to KoMoDo backend.
  \sssctn{Complexity}
  GTK runs natively on most Linux distributions, with the exception of KDE which exclusively uses QT for its applications. GTK implements its own highly optimized standard library and data structures via GLib\cite{glib}. Its use of callbacks has no additional computational complexity, but the tight coupling between callbacks and UI elements increases both development and maintenance time.\\\\
  %
  GTK aims to translate well to other platforms but requires additional work on the client's end. To build a GTK application on Windows, a user must install MinGW and MSys to provide the necessary Linux functionality and headers. GTK on MacOS has similar issues requiring additional steps before the application can be used.

\ssctn{QT}
\fig{\centering\img{0.35}{amd}}{AMD graphics manager built using QT}{qtamd}
QT is a cross platform C++ framework designed with the aim of providing a consistent look and feel across multiple architectures \cite{qt_about}. QT utilises its own preprocessor, the Meta-Object compiler (MOC), to provide UI features such as slots and signals which are listeners that can be coupled with UI elements. It uses a UI markup language called QT Markup Language (QML) to describe/animate the user interface, providing consistency across multiple platforms. These features and more are discussed in this section.
  %
  \sssctn{Meta-Object Compiler (MOC)}
  The MOC is geared towards extending C++ features. As a preprocessor it is executed before any actual compilation occurs\cite{qt_moc}. This pre-processing allows QT to manipulate and change the code that will actually be compiled. By using the $Q_OBJECT$ macro a C++ header file and the subsequent source file are changed to add additional features such as slots and signals. QT features and widgets are written using QT, this allows them to exist on a level of abstraction that the MOC can compile down to native code.
  %
  \sssctn{Slots and Signals}
  Slots and signals are the primary form of communication within QT\cite{qt_slotsnsignals}. A slot is much like a listener, in that it is registered and informed of events. A signal is an event that can be emitted by an object, notifying all slots registered to the event, that a change has occurred. This method of communication promotes loose coupling of the underlying code, promoting extensibility and reusability.

  \sssctn{Internationalization/Localisation}
  Localisation in QT is heavily supported, providing additional functionality which other frameworks such as GTK do not have\cite{qt_localisation}. One such feature is the ability to provide context about a translatable string, allowing translators to better understand the text. Moreover, QT allows text with placeholders such as `name: \%s' to be put into context by supplying additional parameters, which are embedded in the generated locale file for translators to see. \\\\
  %
  Internationalization is also made easy for the developer, providing support for most major languages\cite{qt_international}. The widgets are also designed with internationalization in mind and will automatically display the correct locale.
  %
  \sssctn{QML}
  QML is the UI language underpinning QT interfaces\cite{qt_qml}. QML is used to specify new UI elements, their positions, styling and signals. QML is a JSON like format which can be generated from within QT programmatically or using QTDesigner (like Glade). Like glade, QML provides an abundance of widgets to choose from. The high level abstraction of QT aids in a universal `look and feel' across several platforms. Additionally, the `look and feel' can be themed independently of the platform itself.
  %
  \sssctn{Complexity}
  To provide such a breadth of functionality QT introduces additional steps outside of normal compilation. Consequently, programmers who wish to work on their code would need to already have the QT environment set up as manual compilation is complicated. Furthermore, due to the syntactic sugar that the MOC introduces, programmers are forced to choose between a traditional text editor or the QTCreator, QTs own IDE. Additionally,
  the syntactic sugar correlates to an increase in the size of the generated binaries, something developers would have to worry about when working with embedded devices.\\\\
  %
  QTs slots and signals introduce little overhead to the overall performance of a program, of course running native applications is faster, but this comes at the discretion of the developer. Moreover, because QT uses C++ it comes packed with efficient standard libraries and data structures.
  %
\ssctn{Electron and AngularJS}
\fig{\centering\img{0.23}{atom}}{Atom, a popular text editor built using Electron}{electronatom}
Electron is vastly different to the other two frameworks talked about in this section, electron itself is a runtime environment which interprets and runs Web scripting languages such as HTML or Javascript and uses CSS for styling\cite{electron}. Web technologies in recent year have see a rise in frameworks and as such there are plenty to choose from, in particular AngularJS, a fairly recent Web framework by google. Due to the nature of electron, frameworks such as AngularJS can be run in an application on the desktop, providing a seamless UI written using Web technologies. Furthermore, they can be ran on the Web as a Website.
%
  \sssctn{Electron environment}
  Electron uses Chromium and Node.js to create and run applications on the desktop \cite{electron_about}. From Chromium, electron uses the content module which is responsible for rendering Web pages to `host' the application, in particular electron interfaces with the content module through a shim called brightray\cite{electron_content_module}. A shim is a layer of abstraction which wraps differing platforms, providing a common application programming interface (API). The Node.js service provides the application logic that will be sent to the content module to be displayed.\\\\
  %
  By abstracting away the low level details and utilising already cross compatible elements, electron is able to provide the same functionality regardless of platform.\footnote{But that does mean working with node.js} Furthermore, C++ code can be packaged into a node module, allowing potentially native C code wrapped in C++ to be executed.
  %
  \sssctn{Two-way data binding}
  AngularJS is an abstraction layer on top of Javascript, it provides features which are relevant to both Web and desktop applications\cite{angular}. In particular AngularJS provides two way data binding, this allows the data and model to be bound together\cite{angular_data_binding}. Therefore, a change in the data forces a change in the visual element without the explicit need to define a callback or slot. This is a very powerful tool, allowing faster prototyping of applications without the need for boilerplate code.
  %
  \sssctn{CSS \& styling}
  CSS is nothing new and has been around for a long time, its primary use is to provide styling information for HTML files. Electrons use of Web technologies via an abstraction means that the CSS styling is universal, working out of the box on every platform. Theming the application is as simple as changing CSS elements. Any HTML generated for an application only needs to reference the CSS styling and the content module from chromium will render the result using the specified elements.\\\\
  %
  Electron typically takes care of a platforms window system via another abstraction. Menus\cite{electron_menu} and other window elements are exposed to programmers via a standard API and aim to provide consistency across the supported platforms.
  %
  \sssctn{Internationalization/localisation}
  Unlike our other examples neither AngularJs or Electron come with an internationalization or localisation feature. But, unlike our other examples, electron applications are built using Web technologies and these technologies provide a smorgasbord of pluggable extensions. One such extension is Angular-translate, a dependency which can be added to an application built using Angular\cite{angular_translate}. Angular-translate then exposes similar internationalization/localisation functionality to the other application frameworks. It also has support for plural generation with templated strings.

  \sssctn{Computational complexity}
  Electrons choice to render using HTML and CSS and push content using Node.js comes with added complexity. Although electron is able to provide a plethora of useful features, it does so by trading performance for hackability, using another component to render HTML and CSS. Hackability being the ability to transform and morph existing applications by creating plugins which change or complement their typical behaviour.\\\\
  %
  Hackability also comes at a cost, the ease of using pluggable modules brings its own performance hit, especially when they are being loaded. Importing a module is a synchronous process, each module may also have its own imports, the cascading imports can potentially slow down application startup. Consequently, developers need to think deeply about how to implement their solutions.

\ssctn{Conclusion}

QT is a very mature framework, having been conceived before both GTK and Electron, it has had time to make mistakes and correct them. It provides many features developers are looking for, in particular slots and signals but this comes at the cost of compilation complexity. Alternatively, GTK provides callbacks which keep things simple, but force tight coupling with UI elements. Electron and AngularJS provide similar features to QT but with the added complexity of working with Web technologies.\\\\
%
Electron provides the best styling out of the three frameworks, the universal nature of CSS means that regardless of platform it will be interpreted in a deterministic manner. QT tries to provide a similar experience across its multiple platforms, but is often hindered by the target platform. Consequently, developers are forced to account for the subtle differences between each platform. GTK also suffers from a similar issue, leaving the platform dependent complexities to the developer.\\\\
%
GTK, GLib and Linux are heavily integrated into KoMoDo, in essence a project like this requires that KoMoDo be built again from the ground up removing platform dependencies. To do that would be outside the scope of this particular project. GLib is still a formidable framework and one that was develop due to the closed nature of earlier versions of QT. Although using GTK on multiple platforms is complex it can be done with proper guidance.\\\\
%
Initially before carrying out this research the plan was to use QT for the front-end. As both KoMoDo and the other frameworks were explored, it became apparent that GTK is heavily engrained within KoMoDo, as such using QT would mean one of two things; create a shim which transformed GLib data structures to something QT would understand or alternatively, remake KoMoDo from the ground up using QT. Due to time constraints the latter was deemed not feasible and the former would produce additional undesired complexities. Consequently, GTK is the smart choice to make in this instance. Utilising MinGW and MSys will allow components like the Jimulator to function as if they are being executed in a Linux environment. The jimulator, being the heart of KoMoDo is its own complex program\footnote{It'll need its own dissertation to convert into something modern}.
%QT is much more mature than electron and GTK, features like slots and signals make it easy for developers to work with. The MOC is extendable so features required by a project could be added, for a KoMoDo port all three parts of KoMoDo need to be written in some platform independant way. Qt runs at almost native speeds

%Electron is clean and has access to alot of librarys, the CSS styling and the use of exsisting Webframeworks means that app development is quick and stylish. Requires platform independant code to work well, can be slow due to the copious things its doing
%Electron and QT both require rewrites for KoMoDo to work with them, GTK is heavily integrated into KoMoDo.
%C and electron will require some additional functionality to be added to KoMoDo
%QT would be great if GTK hadn't been so heavily integrated.
